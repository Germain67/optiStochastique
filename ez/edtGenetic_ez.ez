\User declarations : // This section is copied on top of the output file
#include <string>
#include <iostream>
#include <fstream>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <sstream>
#include <iterator>
#include <cmath> //std::abs
#define NB_PAPERS 263

using namespace std;

typedef struct{
  double startHour;
  double endHour;
} Interval;

typedef struct{
  int ID;
  int ID_Track;
  int ID_Session;
  int duration;
  double fuseauHoraire;
  vector<Interval> dispoDay1;
  vector<Interval> dispoDay2;
  vector<Interval> dispoDay3;
} Paper;

ifstream fPaper;
vector<Paper> papers;

\end

\User functions:

template<typename Out>
void split(const std::string &s, char delim, Out result) {
    std::stringstream ss;
    ss.str(s);
    std::string item;
    while (std::getline(ss, item, delim)) {
        *(result++) = item;
    }
}

std::vector<std::string> split(const std::string &s, char delim) {
    std::vector<std::string> elems;
    split(s, delim, std::back_inserter(elems));
    return elems;
}

std::vector<Interval> strToIntervals(std::string str)
{
  vector<Interval> res;
  if(str != "*"){
    std::vector<std::string> horaires = split(str, '[');
    for(size_t i = 1; i < horaires.size() ; i++)
    {
      std::vector<std::string> vals = split(horaires[i], ',');
      Interval cur_interval;
      cur_interval.startHour = atof(vals[0].c_str());
      cur_interval.endHour = atof(split(vals[1], ']')[0].c_str());
      res.push_back(cur_interval);
    }
  }
  return res;
}

void readPapers()
{
  std::ifstream file("Parser/papers.txt");
  std::string line;
  while (std::getline(file, line))
  {
      std::vector<std::string> lineElems = split(line, '|');
      Paper p;
      p.ID = atoi(lineElems[0].c_str());
      p.ID_Track = atoi(lineElems[1].c_str());
      p.ID_Session = atoi(lineElems[2].c_str());
      p.duration = atoi(lineElems[3].c_str());
      if(lineElems[4] == "*")
      {
        p.fuseauHoraire = 0;
      }
      else
      {
        p.fuseauHoraire = atof(lineElems[4].c_str());
      }
      p.dispoDay1 = strToIntervals(lineElems[5]);
      p.dispoDay2 = strToIntervals(lineElems[6]);
      p.dispoDay3 = strToIntervals(lineElems[7]);
      //p.startDate = NULL;
      papers.push_back(p);
  }
}

void printPaper(Paper p){
  std::cout << "ID : " << p.ID << " ID_SESSION : " << p.ID_Session << " ID_Track : " << p.ID_Track << '\n';
  std::cout << "duration : " << p.duration << " fuseauHoraire " << p.fuseauHoraire << '\n';
  if(p.dispoDay1.size() > 0)
  {
    std::cout << "Start hour Dispo day 1" << p.dispoDay1[0].startHour << '\n';
    std::cout << "End hour Dispo day 1" << p.dispoDay1[0].endHour << '\n';
  }
}

struct tm customDateToTm(CustomDate d)
{
  struct std::tm tmTime;
  tmTime.tm_year = d.year - 1900;
  tmTime.tm_mon = d.month - 1;
  tmTime.tm_mday = d.day;
  tmTime.tm_hour = d.hour;
  tmTime.tm_min = d.minute;
  tmTime.tm_sec = d.second;
  return tmTime;
}

bool isBeforeDate(CustomDate d1, CustomDate d2)
{
  struct tm t1 = customDateToTm(d1);
  struct tm t2 = customDateToTm(d2);
  time_t tt1 = mktime(&t1);
  time_t tt2 = mktime(&t2);
  return tt1 < tt2;
}

int differenceMinute(CustomDate d1, CustomDate d2)
{
  struct tm t1 = customDateToTm(d1);
  struct tm t2 = customDateToTm(d2);
  time_t tt1 = mktime(&t1);
  time_t tt2 = mktime(&t2);
  return (abs(tt1 - tt2) / 60);
}

\end

\User CUDA:
//Transfert some variables to GPU here (cudaMalloc, MemCpy)
\end

\User classes :
CustomDate{
  int year;
  int month;
  int day;
  int hour;
  int minute;
  int second;
}
Match {
	CustomDate startDate;
}
GenomeClass{
  Match paper[NB_PAPERS];
}
\end

\Before everything else function:
  readPapers();
\end

\After everything else function:
  //TODO: Afficher les résultats
\end

\At the beginning of each generation function:
//cout << "At the beginning of each generation function called" << endl;
\end

\At the end of each generation function:
//cout << "At the end of each generation function called" << endl;
\end

\At each generation before reduce function:
//cout << "At each generation before replacement function called" << endl;
\end

\GenomeClass::display:
\end

\GenomeClass::initialiser : // "initializer" is also accepted
  for(int i = 0; i < NB_PAPERS; i++)
  {
    CustomDate d;
    d.year = 2015;
    if(tossCoin())
    {
      d.month = 9;
      d.day = 30;
      d.hour = (int) random(6,24);
    }
    else
    {
      d.month = 10;
      d.day = 1;
      d.hour = (int) random(0,24);
    }
    d.minute = (int) random(0, 60);
    d.second = (int) random(0, 60);
    Genome.paper[i].startDate = d;
  }
\end

\GenomeClass::crossover :
  for(int i=0; i < NB_PAPERS; i++)
  {
    if(tossCoin())
    {
      child.paper[i] = parent1.paper[i];
    }
    else
    {
      child.paper[i] = parent2.paper[i];
    }
  }
\end

\GenomeClass::mutator : // Must return the number of mutations
  float fMutProbPerGene=((currentGeneration%40)/40.0)*(NB_PAPERS*.005)+.1;//.235;
  int nbMutations = 0;
  for(int i = 0; i < NB_PAPERS; i++)
  {
    if (tossCoin(fMutProbPerGene)){
      CustomDate d;
      d.year = 2015;
      if(tossCoin())
      {
        d.month = 9;
        d.day = 30;
        d.hour = (int) random(6,24);
      }
      else
      {
        d.month = 10;
        d.day = 1;
        d.hour = (int) random(0,24);
      }
      d.minute = (int) random(0, 60);
      d.second = (int) random(0, 60);
      Genome.paper[i].startDate = d;
      nbMutations++;
    }
  }
	return nbMutations;
\end

\GenomeClass::evaluator : // Returns the score as a real value
  //1/ Pour tout papers du track 15, il faut pas qu'il y ait un autre papers en meme temps
  //2/ Pour chaque paper, vérifier que c'est dans les dispo du chercheur
  //3/ Pour tout paper d'une meme session, il ne doit pas y avoir un autre paper en meme temps
  //4/ Il ne doit pas y avoir trop d'écart entre chaque paper
  CustomDate endDate;
  CustomDate endDate2;
  //int nbDe15 = 0;
  int totalScore = 0;
  int chercheurNonDispo = -100;
  int paperMemeSession = -100;
  int sessionPleniere = -100000;
  int ecartFaible = -1 ; // <2h -1 par heure
  int ecartMoyen = -5; // <4h -5 par heure
  int ecartFort = -10; // >4h -10 par heure
  std::vector<int>numSessions {4,5,6,7,8,9,10,11,12,13,15,16};

  /* for(int i = 0; i< NB_PAPERS;i++) // on compte le nombre de paper des sessions plénières
  {
     if(papers[i].ID_Session == 15)
     {
        nbDe15++;
     }
  }*/

  for(int i = 0; i < NB_PAPERS; i++) // check en même temps
  {
    for(int j = i + 1 ; j < NB_PAPERS; j++)
    {
      if(papers[i].ID_Session == papers[j].ID_Session || papers[i].ID_Session == 15 || papers[j].ID_Session == 15) //paper même session ou paper 15
      {
        endDate = Genome.paper[i].startDate;
        endDate.hour += papers[i].duration;
        if(endDate.hour >= 24)
        {
           endDate.hour = endDate.hour%24;
           endDate.day += 1;
        }
        if(endDate.day >= 30)
        {
           endDate.day = endDate.day%30;
           endDate.month +=1;
        }
        //TODO : Check qu'il n'y ait pas overlapping
        /*if(!isBeforeDate(endDate,Genome.paper[j].startDate))
        {
          if(isBeforeDate(Genome.paper[i].startDate,Genome.paper[j].startDate))
          {
            totalScore += paperMemeSession;
            if(papers[i].ID_Session==15) //si en plus il s'agit de la session 15
              totalScore += sessionPleniere;
          }
        }*/
      }
    }
  }

  for(int i = 0; i < NB_PAPERS; i++) // si Chercheur dispo
  {
        endDate = Genome.paper[i].startDate;
        int jour = endDate.day;
        int heure = endDate.hour;
        if(jour ==30)
        {
           for(size_t j = 0; j< papers[i].dispoDay1.size() ; j++)
           {
              if(heure < papers[i].dispoDay1[j].startHour && heure > papers[i].dispoDay1[j].endHour)
                totalScore += chercheurNonDispo;
           }
        }
        if(jour == 1)
        {
           for(size_t j = 0; j< papers[i].dispoDay2.size() ; j++)
           {
              if(heure < papers[i].dispoDay2[j].startHour && heure > papers[i].dispoDay2[j].endHour)
                totalScore += chercheurNonDispo;
           }
        }
        if(jour == 2)
        {
           for(size_t j = 0; j< papers[i].dispoDay3.size() ; j++)
           {
              if(heure < papers[i].dispoDay3[j].startHour && heure > papers[i].dispoDay3[j].endHour)
                totalScore += chercheurNonDispo;
           }
        }
  }

  for(size_t i = 0 ; i<numSessions.size(); i++) //vérification écart
  {
    vector<CustomDate> papiers;
    vector<int> duree;
    for(int j = 0; j<NB_PAPERS ; j++)
    {
      if(papers[j].ID_Session == numSessions[i])
      {
        papiers.push_back(Genome.paper[j].startDate);
        duree.push_back(papers[j].duration);
      }
    }
    for(size_t k = 0 ; k < papiers.size()-1; k++)
    {
      for(size_t g = k ; g < papiers.size(); g++)
      {
        endDate = papiers[k];
        endDate.hour += duree[k];
        if(endDate.hour >24)
        {
          endDate.hour = endDate.hour%24;
          endDate.day += 1;
        }
        if(endDate.day>30)
        {
          endDate.day = endDate.day%30;
          endDate.month +=1;
        }

        endDate2 = papiers[g];
        endDate2.hour += duree[g];
        if(endDate2.hour >24)
        {
          endDate2.hour = endDate2.hour%24;
          endDate2.day += 1;
        }
        if(endDate2.day>30)
        {
          endDate2.day = endDate2.day%30;
          endDate2.month +=1;
        }
        int diff = differenceMinute(endDate,endDate2);
        if(diff<120)
        {
          totalScore += diff * ecartFaible;
        }
        else if(diff<240)
        {
          totalScore += diff * ecartMoyen;
        }
        else
        {
          totalScore += diff * ecartFort;
        }
      }
    }
  }

  return totalScore;
\end

\User Makefile options:
  CPPFLAGS+="-std=c++11"
\end

\Default run parameters :        // Please let the parameters appear in this order
  Number of generations : 300    // NB_GEN
  Time limit: 0 			           // In seconds, 0 to deactivate
  Population size : 64		   //POP_SIZE
  Offspring size : 64// or a xx%
  Mutation probability : 0.8       // MUT_PROB
  Crossover probability : 1      // XOVER_PROB
  Evaluator goal : maximise      // maximise
  Selection operator: Tournament 0.6
  Surviving parents: 100%        // Percentage or absolute
  Surviving offspring: 100%      // Percentage or absolute  d
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 2

  Elitism: strong			           // Weak or Strong
  Elite: 1
  Print stats: true				       // Default: 1
  Generate csv stats file:true
  Generate gnuplot script:false
  Generate R script:false
  Plot stats:true				         // Default: 0

  Remote island model: true
  IP file: ip.txt 			         // List of IP:PORT of islands to send individuals to
  Migration probability: 0.3    // Probability of sending an individual per generation
  Server port : 2929

  Save population: false
  Start from file:false
\end
