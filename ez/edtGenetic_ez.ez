\User declarations : // This section is copied on top of the output file
#include <string>
#include <iostream>
#include <fstream>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <sstream>
#include <iterator>

using namespace std;

typedef struct{
  int startHour;
  int endHour;
} Interval;

typedef struct{
  int ID;
  int ID_Track;
  int ID_Session;
  int duration;
  double fuseauHoraire;
  vector<Interval> dispoDay1;
  vector<Interval> dispoDay2;
  vector<Interval> dispoDay3;
  struct tm* startDate;
} Paper;

ifstream fPaper;
vector<Paper> papers;

\end

\User functions:

template<typename Out>
void split(const std::string &s, char delim, Out result) {
    std::stringstream ss;
    ss.str(s);
    std::string item;
    while (std::getline(ss, item, delim)) {
        *(result++) = item;
    }
}


std::vector<std::string> split(const std::string &s, char delim) {
    std::vector<std::string> elems;
    split(s, delim, std::back_inserter(elems));
    return elems;
}

std::vector<Interval> strToIntervals(std::string str)
{
  vector<Interval> res;
  if(str == "*"){
    return res;
  }
  std::vector<std::string> day = split(str, '[');
  for(int i = 0; i<day.size() ; i++)
  {
    Interval cur_interval;
    std::vector<std::string> vals = split(day[i], ',');
    cur_interval.startHour = atoi(vals[0].c_str());
    cur_interval.endHour = atoi(split(vals[1], ']')[0].c_str());
    res.push_back(cur_interval);
  }
  return res;
}

void readPapers()
{
  std::ifstream file("../Parser/papers.txt");
  std::string line;
  while (std::getline(file, line))
  {
      std::vector<std::string> lineElems = split(line, '|');
      Paper p;
      p.ID = atoi(lineElems[0].c_str());
      p.ID_Track = atoi(lineElems[1].c_str());
      p.ID_Session = atoi(lineElems[2].c_str());
      p.duration = atoi(lineElems[3].c_str());
      if(lineElems[4] == "*")
      {
        p.fuseauHoraire = 0;
      }
      else
      {
        p.fuseauHoraire = atof(lineElems[4].c_str());
      }
      p.dispoDay1 = strToIntervals(lineElems[5]);
      p.dispoDay2 = strToIntervals(lineElems[6]);
      p.dispoDay3 = strToIntervals(lineElems[7]);
      p.startDate = NULL;
      papers.push_back(p);
  }
}

void printPaper(Paper p){
  std::cout << "ID : " << p.ID << " ID_SESSION : " << p.ID_Session << " ID_Track : " << p.ID_Track << '\n';
  std::cout << "duration : " << p.duration << " fuseauHoraire " << p.fuseauHoraire << '\n';
  if(p.dispoDay1.size() > 0)
  {
    std::cout << "Start hour Dispo day 1" << p.dispoDay1[0].startHour << '\n';
    std::cout << "End hour Dispo day 1" << p.dispoDay1[0].endHour << '\n';
  }
}

\end

\User CUDA:
//Transfert some variables to GPU here (cudaMalloc, MemCpy)
\end

\User classes :
Match {
	int mdr;
}
GenomeClass {
  Match paper[200];
}
\end

\Before everything else function:
  readPapers();
\end

\After everything else function:
\end

\At the beginning of each generation function:
//cout << "At the beginning of each generation function called" << endl;
\end

\At the end of each generation function:
//cout << "At the end of each generation function called" << endl;
\end

\At each generation before reduce function:
//cout << "At each generation before replacement function called" << endl;
\end

\GenomeClass::display:
\end

\GenomeClass::initialiser : // "initializer" is also accepted
  //TODO: initialisation
\end

\GenomeClass::crossover :
  //TODO: croisements
\end

\GenomeClass::mutator : // Must return the number of mutations
  //TODO: mutations
\end

\GenomeClass::evaluator : // Returns the score as a real value
  //TODO: eval
\end

\User Makefile options:
  //CPPFLAGS+="-std=c++11"
\end

\Default run parameters :        // Please let the parameters appear in this order
  Number of generations : 300    // NB_GEN
  Time limit: 0 			           // In seconds, 0 to deactivate
  Population size : 64		   //POP_SIZE
  Offspring size : 64// or a xx%
  Mutation probability : 0.8       // MUT_PROB
  Crossover probability : 1      // XOVER_PROB
  Evaluator goal : maximise      // maximise
  Selection operator: Tournament 0.6
  Surviving parents: 100%        // Percentage or absolute
  Surviving offspring: 100%      // Percentage or absolute  d
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 2

  Elitism: strong			           // Weak or Strong
  Elite: 1
  Print stats: true				       // Default: 1
  Generate csv stats file:true
  Generate gnuplot script:false
  Generate R script:false
  Plot stats:true				         // Default: 0

  Remote island model: true
  IP file: ip.txt 			         // List of IP:PORT of islands to send individuals to
  Migration probability: 0.3    // Probability of sending an individual per generation
  Server port : 2929

  Save population: false
  Start from file:false
\end
